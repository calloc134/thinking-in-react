# React の思想を考える - 第 1 回 はじめに: 宣言的 UI と UI フレームワーク

## 注意

今回は、Web における UI フレームワークに絞って解説を行う。
そのため、React Native などについては言及を避ける。

また、誤りや間違いの指摘(いわゆるマサカリ) は大歓迎である。
気軽に Issue や Twitter (現 X) などで指摘してほしい。

- 宣言的 UI
  - How (UI をどう描くか) を記述せず、 What (UI がどうあるべきか) を記述するスタイル
  - フレームワークには、仮想的に UI の状態を表現したオブジェクトである 「要素」が存在する
    - 何らかの方法で生成された「要素」を フレームワーク が受け取り
    - 以下の 2 つを比較し、差分検知を行う
      - フレームワーク内部に保持されている 過去の内部状態
      - 今回新しく作成され フレームワークに与えられる「要素」
    - その結果、以下のものが得られる
      - UI の差分情報
      - 今回新しく作成した 現在の内部状態
    - 洗い出した差分を実 DOM に適用することで 実際の UI を更新するという設計を行う
    - また、今回新しく作成した現在の内部状態は、次回以降利用するため
    - フレームワーク内部に保持される
  - 開発者は、その「要素」を生成する仕組み のみを実装すれば良い
    - 関数で実装
    - クラスで実装
  - フレームワークは、要素を生成する関数やクラスを実行し、要素を取得する
  - この設計により、以下の利点が得られる
    - UI 更新のロジックを フレームワーク に任せることができる
    - UI の状態を 宣言的に記述できるため、コードの可読性・保守性が向上する
  - 具体例
    - React
      - 開発者は 要素を生成する仕組みを 関数(関数コンポーネント) で実装する
      - React が要素生成関数 (関数コンポーネント) を呼び出し、要素を受け取る
      - あとは React が 要素の差分を検知し、実 DOM に最小限の変更を加える
    - Vue
      - 開発者は 要素を生成する仕組みを レンダリング関数 で実装する
      - Vue がレンダリング関数を呼び出し、要素を受け取る
      - あとは Vue が 要素の差分を検知し、実 DOM に最小限の変更を加える
  - 差分検知アルゴリズム → Reconciliation
    - Reconciliation とは UI のみに存在する単語ではなく、
    - 宣言的なシステムを構築する際に広く用いられる概念である
    - 例: Kubernetes の Reconciliation Loop
- コンポーネント合成をベースとするアーキテクチャ
  - UI を 再利用可能な部品 (コンポーネント) に分割し、組み合わせて UI を構築するスタイル

## React の思想を語る前に

- 今回の解説では「仮想 DOM」という言葉を使わない
  - 「仮想 DOM」という言葉は、誤解をまねく
  - 仮想 DOM という言葉は、以下の 2 つの異なる概念を混同してしまう
    - React が 受け取る 要素
      - React 要素 (仮想的に UI を記述したオブジェクト)
    - React が 内部的に保持する 内部状態
      - Fiber ツリー (仮想的に 状態を表現したデータ構造)
  - React の文脈においては、
    - それぞれ、「React 要素」 と 「Fiber ツリー」 と呼んでいくことにする

これ以降は、 React 特有の思想 について解説していく。
