# React の思想を考える - 第 3 回 useEffect を通して考える 副作用の記述

今回は、React 特有の思想のうち、副作用の記述に絞って解説を行う。

- f(...) = React 要素 という純粋関数性 を保ち、副作用を外部に逃がすための 手段
  - React は f(...) = React 要素 という純粋関数性 を保つことを前提に設計されていることは前述した
  - React 要素 を生成する関数コンポーネントには、
    - React 管轄外の 外部システム とのやり取り(副作用) の記述 を含めるべきではない
    - React 管轄外 の 外部システム とのやり取りの例は 前述の通り
  - そのため React は、関数コンポーネント実行の「外部」で副作用 の実行を設定する手段を提供している
  - 副作用の記法の解説をする前に、重要な仕組みである useEffect について触りだけ解説する
  - 前提知識: useEffect
    - まずは この useEffect の技術的な詳細を解説する
    - useEffect は、技術的に見れば
    - React 要素から生成された 変更が 実 DOM に反映された後 に
      - 任意の処理を差し込むことができる仕組みのこと
      - 以下の 2 つの処理が差し込める
        - ①. セットアップ処理
          - 実 DOM ノードが 反映された後 (マウント直後) に実行される処理
        - ②. クリーンアップ処理
          - 実 DOM ノードが 破棄された後 (アンマウント直後) に実行される処理
      - この場合の処理の流れは以下の通り
        - 1. コンポーネントがマウントされるときに セットアップ処理 が実行される
        - 2. コンポーネントがアンマウントされるときに クリーンアップ処理 が実行される
      - また、依存配列というものを指定することもできる
        - 依存配列: 副作用処理が依存している入力値
        - 副作用処理が依存している値 とはつまり React が値の変化を検知する必要のある値である ということ
        - 依存配列には、状態群 (state, props, context) や 状態群から導出した値 など
        - React 管轄内の値 のみを含める必要がある
      - 依存配列を指定すると、処理が以下のようになる
        - ①. セットアップ処理
          - 実 DOM ノードが 反映された後 (マウント直後) に実行される (従来と同じ)
          - 依存配列が変化したタイミングで、前回のクリーンアップ処理の後に実行される
        - ②. クリーンアップ処理
          - 実 DOM ノードが 破棄された後 (アンマウント直後) に実行される (従来と同じ)
          - 依存配列が変化したタイミングで、次回のセットアップ処理の前に実行される
      - この場合の処理の流れは以下の通り
        - 1. コンポーネントがマウントされるときに セットアップ処理 が実行される
        - 2. 依存配列の値が変化したタイミングで、前回のクリーンアップ処理 が実行される
        - 3. 続けて、今回のセットアップ処理 が実行される
        - 4. コンポーネントがアンマウントされるときに クリーンアップ処理 が実行される
      - 注意点
        - 余計な依存関係を増やさないように気をつける
          - useEffect の内部 でのみ利用する変数・関数は
          - できるだけ useEffect の内部で定義するようにする
          - これにより、依存配列に含めるべき変数・関数の数を減らすことができる
          - また定数であれば、そもそも 関数コンポーネントの外部で定義してしまうのも手
      - 余談: useEffect の依存配列は React 管轄内の値 のみを含める必要がある
        - useEffect の依存配列は 「どのような値でも変化を検知できる」わけではない
          - 別の言い方をすると、RxJS のように 値に購読を設定して
          - 値の変化を検知する という仕組みではない
        - そのため、React 外部の値 を依存配列に含めても 変化を検知できない
        - 仕組みは以下の通り
          - React の仕組みとして、
          - 状態群 (state, props, context) の変化に合わせて 関数コンポーネントを再実行する ことは 前述の通り
          - 関数コンポーネントが再実行されたとき、
          - 前回の実行時と今回の実行時の 依存配列内の値 をそれぞれ比較し
          - いずれかの値が変化していた場合にのみ
          - useEffect 内の処理を再実行する仕組み となっている
        - そのため、依存配列に React 管轄外 である 外部システムの値を含めたとしても
          - React に外部システムの値の変化を検知する仕組みがないため
          - 依存配列に React 外部の値を含めることは意味がない
          - 依存配列には React 管轄内の値 のみを含める必要がある
      - useEffect の技術的な側面は以上である
        - しかし、技術的な側面だけ見て useEffect を利用すると
        - React の設計思想に反した使い方をしてしまう可能性が高い

  - 副作用 の持つ特性
    - 副作用が React 管轄外のシステムとのやり取りであることは前述の通り
    - すべての 副作用は、何かの事象に反応して発生する トリガ処理とみなすことができる
      - React が 実 DOM を反映した後・破棄した後 を トリガ として発生する副作用
      - ユーザが意図を持って行った操作 を トリガ として発生する副作用
      - React の 状態群 (state, props, context) や 状態群から導出した値 の値が変化したこと を トリガ として発生する副作用 など
  - React における 副作用の記述
    - React において、典型的な 副作用の記述を区分してみると、いくつかのパターンに区分することができる
      - 1. React が DOM ノードを 反映・破棄 したタイミングで 外部のシステムを初期化・破棄 する副作用
      - 2. React 管轄内の値 に基づいて、外部システム に その値を反映する 副作用
      - 3. 何かのイベントに応じて 実行される副作用
    - これらについて それぞれのトリガが何であるか、どのように実装するべきかを解説する
      - 1. React が DOM ノードを 反映・破棄 する タイミングで 外部のシステムを初期化・破棄 する副作用である場合
        - 何かの事象 = React が DOM ノードを 反映・破棄 したという事象に対するトリガ といえる
        - エフェクトを利用して記述せよ
        - 具体的には useEffect を利用し、useEffect のセットアップ関数に 副作用処理を記述せよ
      - 2. React 管轄内の値 に基づいて、外部システム に その値を反映する 副作用である場合
        - React 管轄内の値 = 状態群(state, props, context) および 状態群から派生させた値 など
        - 1 の事象に加え、React の 管轄内の値 が変化したという事象に対するトリガ といえる
        - 依存配列に React 管轄内の値 も含めてエフェクトを利用せよ
        - 具体的には useEffect を利用し、依存配列に React 管轄内の値 を含めてから 1 と同様に 副作用処理を記述せよ
      - 3. 何かのイベントに応じて実行される副作用である場合
        - 何かの事象 = ユーザが意図を持って行った操作 に対するトリガ といえる
        - イベントハンドラ内に記述せよ
        - 具体的には、イベントハンドラ として コールバック関数を定義し、
        - その関数内に副作用処理を記述せよ
    - 以上の 3 つが、React における 典型的な副作用処理のパターンと
      - それぞれに対応する React が提供する 副作用実行手段 である
    - ここから 具体的な解説を行っていく
      - 1. React が DOM ノードを 反映・破棄 したタイミングで 外部のシステムを初期化・破棄 する副作用
        - 意図:
          - DOM ノード が React によって 画面に 反映・破棄 されたタイミングというのは、
          - React の コンポーネントの新規作成・破棄 が 実 DOM ノードに反映されたタイミングといえる
          - 反映という事象をトリガとして 外部システム の 初期化・破棄 を 行うことで
          - React 外部のシステム と React コンポーネント の ライフサイクル を同期させる という意図を持つ
        - 処理の流れ
          - 1. セットアップ関数・クリーンアップ関数内部に、セットアップ処理・クリーンアップ処理 という 副作用を記述する
          - 2. useEffect へ これらの関数を渡す
          - 3. React が DOM ノードを 反映 したタイミングで セットアップ関数 が実行され、副作用が実行される
          - 4. React が DOM ノードを 破棄 したタイミングで クリーンアップ関数 が実行され、副作用が実行される
        - 例:
          - ネットワーク越しの外部サーバへの接続確立
            - 初期化 = 外部サーバへの接続確立
              - `createConnection()` のような関数を呼び出し、接続を確立
            - 破棄 = 外部サーバへの接続解除
              - `connect.close()` のような関数を呼び出し、接続を解除
              - クリーンアップ関数で実装する
            - 処理の流れ
              - 1. コンポーネントがマウントされるときに 接続を確立
              - 2. コンポーネントがアンマウントされるときに 接続を解除
          - React に対応していない コンポーネントライブラリ の初期化・破棄
            - 初期化 = コンポーネントライブラリの初期化
              - useRef (後述) で DOM ノード を取得し そこに React に対応していない コンポーネントライブラリ を代入する
            - 破棄 = コンポーネントライブラリの破棄
              - DOM ノードから コンポーネントライブラリ の `destroy()` のような関数を呼び出し、破棄する
              - クリーンアップ関数で実装する
            - 処理の流れ
              - 1. コンポーネントがマウントされるときに コンポーネントライブラリを初期化
              - 2. コンポーネントがアンマウントされるときに コンポーネントライブラリを破棄
          - 亜種: 外部サーバへのログ送信
            - 外部サーバへのログ送信 のような 処理の初期化・破棄 も β の一種と捉えられるが、
            - この場合は 破棄が必要ない
            - 初期化 = ログ送信
              - `fetch` のような関数を呼び出し、ログを送信
            - 破棄 = なし
            - 処理の流れ
              - 1. コンポーネントがマウントされるときに ログを送信
      - 2. React 管轄内の値 に基づいて、外部システム に その値を反映する 副作用
        - 意図:
          - React 管轄内の値 (state, props, context など) が変化したという事象をトリガとして
          - 外部システム に その値を反映 することで
          - React 外部のシステム と React コンポーネント の 状態 を その都度同期させる という意図を持つ
        - 処理の流れ
          - 1. セットアップ関数・クリーンアップ関数内部に、セットアップ処理・クリーンアップ処理 という 副作用を記述する
          - 2. useEffect へ これらの関数を渡す
          - 3. 依存配列に state を含める
          - 4. React が DOM ノードを 反映 したタイミングで セットアップ関数 が実行され、副作用が実行される
          - 5. state の値が変化したタイミングで、前回のクリーンアップ関数 が実行され、副作用が実行される
          - 6. 続けて、今回のセットアップ関数 が実行され、副作用が実行される
          - 7. React が DOM ノードを 破棄 したタイミングで クリーンアップ関数 が実行され、副作用が実行される
        - 例:
          - 複数回実行できる 命令的 API を持つ DOM ノード の直接操作
            - 具体例: `<video>` の再生制御
            - React の state に合わせて 再生・一時停止 を切り替える
              - DOM ノード を useRef (後述) で取得し、それに対して 再生・一時停止 を指示
            - 宣言的な React の state の世界から、命令的な DOM ノード の指示へ橋渡しを行うイメージ
              - この場合、依存配列に state を含める
            - セットアップ関数 = state の値に合わせて 再生・一時停止 を実行
            - また、この場合はクリーンアップ関数は不要
            - 処理の流れ
              - 1. コンポーネントがマウントされるときに state の値に合わせて 再生・一時停止 を実行
              - 2. state の値が変化したときに 再度 state の値 に合わせて 再生・一時停止 を実行
              - 3. コンポーネントがアンマウントされるときは 特に何も実行しない
          - 一度しか実行できない 命令的 API を持つ DOM ノード の直接操作
            - 具体例: `<dialog>` の開閉制御
            - React の state に合わせて 開く・閉じる を切り替える
              - DOM ノード を useRef (後述) で取得し、それに対して showModal() / close() を指示
            - この場合 気をつけること
              - showModal() / close() は 一度しか実行してはいけない
                - showModal() で 開いた dialog 要素 に対して
                - 再度 showModal() を実行すると エラーになる
              - そのため、依存配列に state を含めるだけでなく
              - クリーンアップ関数も実装し、close() を実行するようにする
              - このようにすることで、一度しか実行できない命令的 API を安全に扱うことができる
            - セットアップ関数 = isOpen が true の場合に showModal() を実行
            - クリーンアップ関数 = 常に close() を実行
            - 処理の流れ
              - 1. コンポーネントがマウントされるときに セットアップ処理として isOpen の値が true なら showModal() を実行
              - 2. isOpen の値が変化したときに まず クリーンアップ処理として close() を実行
              - 3. 続けて セットアップ処理として isOpen の値が true なら showModal() を実行
              - 3. コンポーネントがアンマウントされるときに close() を実行
      - 3. 何かのイベントに応じて 実行される副作用
        - 意図:
          - ユーザが意図を持って行った操作 (クリック、入力、スクロール など) をトリガとして 発生する副作用を
          - イベントハンドラ内に閉じ込めることで
          - React の関数コンポーネントの実行外部に 副作用処理を逃がす という意図を持つ
        - そもそもイベントハンドラ とは
          - 何かのイベントが発生したときに、対応する処理を実行するコールバック関数
            - イベントハンドラとは 関数コンポーネントの外部で実行される関数である
            - そのため イベントハンドラ内には 外部システムに対して影響を与える処理を記述して良い
            - イベントハンドラは 副作用の実行手段の一つである
          - 特定のイベントに紐づく副作用は イベントハンドラに記述する必要がある
        - 例:
          - 特定のボタンが押されたイベントに対して、処理を実行する
          - キーボードが押されたイベントに対して、処理を実行する
          - ウィンドウのリサイズイベントに対して、処理を実行する
          - 外部サーバからの websocket 通知イベントに対して、処理を実行する
          - setTimeout や setInterval のタイマーイベントに対して、処理を実行する
            - 余談: setTimeout や setInterval の場合は
              - 厳密には イベントハンドラ ではないが、
              - 「一定時間経過後」や 「一定時間ごと」というイベントで発火する
              - イベントハンドラ 的な性質を持つため、ここでは イベントハンドラ の一種として扱う
        - 処理の流れ
          - 1. イベントハンドラ関数内部に、副作用処理を記述する
          - 2. 「任意のイベントハンドラ登録手段」を用いて イベントハンドラ関数を イベントハンドラに登録する
          - 3. ユーザが意図を持って行った操作 によって イベントハンドラ関数 が実行され、副作用が実行される
        - 「任意のイベントハンドラ登録手段」 とは
          - イベントハンドラの登録手段 は いくつか存在する
          - 代表的なものとしては、以下の 2 つがある
            - 1. JSX の イベントハンドラ属性 を用いる手段
            - 2. useEffect (パターン 1) を利用する手段
            - 2 の useEffect を利用する手段でイベントハンドラを登録するということは。
              - 先程解説した 1 のパターンを イベントハンドラ登録に応用する ということである
              - つまり、1 のパターンを 3 の内部に組み込む運用になる、ということである
              - イベントハンドラ自体も副作用であり、イベントハンドラの登録も副作用であるということに気をつける
          - 1. JSX の イベントハンドラ属性 を用いる手段
            - イベントハンドラを設定するための基本的な手段
            - 関数コンポーネントが生成する React 要素 の 属性として
            - イベントハンドラとなる関数を登録する手段
              - 例: onClick 属性 に ボタンが押された時の処理を登録する
            - 例:
              - ボタンが押された時に新しくウィンドウを開くイベントハンドラの登録
                - `onClick` 属性 に `() => window.open(...)` のようなイベントハンドラを登録する
              - ボタンが押されたときに 外部サーバにデータを送信するイベントハンドラの登録
                - `onClick` 属性 に `() => fetch(...)` のようなイベントハンドラを登録する
            - React が管轄している要素 に対して イベントハンドラを登録する手段であるため
              - 開発者は イベントハンドラの登録・解除を自力で実装する必要がなく
              - React が自動で イベントハンドラの登録・解除を行ってくれる
          - 2. useEffect (パターン 1) を利用する手段
            - 先程解説したイベントハンドラ属性は 対応する React 要素 が存在しない場合には利用できない
            - 例えば
              - キーボードが押されたときに処理を実行したい場合
              - ウィンドウのリサイズ時に処理を実行したい場合
              - 外部サーバからの websocket 通知を受け取ったときに処理を実行したい場合
              - setTimeout や setInterval を用いて 時間経過後に処理を実行したい場合
            - その場合、useEffect を用いて
              - イベントハンドラの登録・解除を自力で実装する必要がある
            - 例:
              - キーボードが押されたときに処理を実行するようなイベントハンドラの登録・解除
                - イベントハンドラの登録: `window.addEventListener('keydown', handler)` のような関数を呼び出し、登録
                - イベントハンドラの解除: `window.removeEventListener('keydown', handler)` のような関数を呼び出し、解除
              - ウィンドウのリサイズ時に処理を実行するようなイベントハンドラの登録・解除
                - イベントハンドラの登録: `window.addEventListener('resize', handler)` のような関数を呼び出し、登録
                - イベントハンドラの解除: `window.removeEventListener('resize', handler)` のような関数を呼び出し、解除
              - 外部サーバからの websocket 通知を受け取ったときに処理を実行するようなイベントハンドラの登録・解除
                - イベントハンドラの登録: `websocket.addEventListener('message', handler)` のような関数を呼び出し、登録
                - イベントハンドラの解除: `websocket.removeEventListener('message', handler)` のような関数を呼び出し、解除
              - setTimeout や setInterval を用いて 時間経過後に処理を実行するようなイベントハンドラの登録・解除
                - イベントハンドラの登録: `const id = setTimeout(handler, delay)` や `const id = setInterval(handler, interval)` のような関数を呼び出し、登録
                - イベントハンドラの解除: `clearTimeout(id)` や `clearInterval(id)` のような関数を呼び出し、解除
            - 余談: useEffectEvent
              - useEffect で イベントハンドラを登録・解除する場合、
                - イベントハンドラ内 で React 管轄内の値 (state, props, context) を参照していると
                - eslint により それらの値を 依存配列 に含めるように指摘される場合がある
              - しかし、イベントハンドラの登録・解除 は 副作用の登録・解除 であり
                - 依存配列に React 管轄内の値 を含めてしまうと 不要なタイミングで イベントハンドラの登録・解除 が発生してしまう
              - その場合、あえてイベントハンドラ の コールバック関数を useEffect 外部で生成し、
              - 更に useEffectEvent を用いて コールバック関数をラップする
                - これにより、イベントハンドラ内 で React 管轄内の値 を安全に参照できるようになり
                - かつ 依存配列に React 管轄内の値 を含める必要がなくなる
              - また useEffectEvent を用いることで
                - イベントハンドラ内 で参照している React 管轄内の値 (state, props, context) について
                - 常に 最新の値 を参照できるようになる
          - イベントハンドラ属性と useEffect の使い分け
            - React 要素の中で イベントハンドラ属性を用いることが可能な場合は
              - 基本的にこの手段を用いることが推奨される
              - しかし 該当する React 要素 が存在しない場合は イベントハンドラ属性を用いることができないため
              - useEffect を利用して 副作用を設定する必要がある
            - useEffect は あくまでも イベントハンドラで副作用を設定できない場合の補完手段であるため、
              - useEffect を用いる場合は 本当にイベントハンドラで副作用を設定できないのかを 注意深く検討する必要がある
            - イベントハンドラ属性 → React が 管轄している要素であるため イベントハンドラの登録・解除を React が自動で行ってくれる
            - useEffect → React が 管轄していない要素であるため 開発者が イベントハンドラの登録・解除を自力で実装する必要がある
              - 不慣れな場合、クリーンアップ関数で イベントハンドラの解除を行うのを忘れがちになる
                - パターン 1 の useEffect と同様の注意点がある
              - しっかり忘れずに実装すること
    - 典型的な 副作用処理のパターン と それぞれに対応する 副作用実行手段 を解説した
    - 実装したい副作用の内容に応じて、これらの副作用実行手段を使い分ける必要がある
      - このパターンに当てはまらない場合は 臨機応変に対応しよう
      - しかし よく観察してみれば これらのパターンの融合や亜種であり
      - 基本的には これらのパターンに帰着できることが多い
    - 余談: 今回解説しなかった useEffect の使い方: 外部システムの値 → React の状態同期
      - 今回は、外部システムの値 → React の状態同期 という使い方は解説しなかった
      - これらの方法は useEffect を利用するよりも
      - 別の手段を用いることが推奨されるためである
      - 具体的には、以下の手段がある
      - 同期的な値の読み取り
        - `localStorage` や `IndexedDB` のような
        - ブラウザのストレージ からの同期的な値の読み取りにも useEffect を利用することはできるが、推奨されない
        - 推奨する手段は以下の通り
          - React 18 で導入された `useSyncExternalStore` の利用
          - React 外部のシステムの値を同期的に読み取るための手段を提供している
          - これにより、React 外部のシステムの値を React の状態として扱うことができる
          - 詳細は後述
      - 非同期なデータフェッチ
        - `fetch` のような HTTP クライアント を用いた
        - 非同期なデータフェッチ にも useEffect を利用することはできるが、推奨されない
        - 推奨する手段は以下の通り
          - React Query, SWR のような データフェッチ支援ライブラリ を利用する
        - これらのライブラリは
          - 外部サーバのデータを React の state と同期させるための手段を提供しており、
          - 自前で useEffect を用いて データフェッチ周りの処理を実装する必要がなくなる
          - また キャッシュ管理 の 他にも 再試行、ポーリング、データの永続化などの機能を提供している
          - これらの処理は 独自実装すると非常に難しく コストが高いが
          - これらのライブラリを利用することで ライブラリに実装を任せることができる
          - また、後述する コンポーネントのサスペンド機能も提供していることが多い
        - したがって、
          - 非同期なデータフェッチ に useEffect を用いることは避け、
          - これらの専用ライブラリを利用することが推奨される
    - 副作用 パターン分岐フローチャート
      - A. 副作用は 何かのイベントに応じて 実行される副作用 であるか？
        - Yes → B へ
        - No. → C へ
      - B.
        - イベントハンドラに副作用を記述する手段を用いる
        - React 要素に イベントハンドラ属性を用いてイベントハンドラを登録できるか？
        - Yes → イベントハンドラ属性を利用する手段を用いる (パターン 3a)
        - No. → useEffect (パターン 1) を利用する手段を用いる (パターン 3b)
      - C.
        - 外部システムへの同期と捉える
        - 副作用は React 管轄内 の値が変化したこと を トリガ として 実行される副作用 であるか？
        - Yes → 依存配列に React 管轄内の値 を含めて useEffect を利用する手段を用いる (パターン 2)
        - No. → D へ
      - D.
        - 副作用は React が DOM ノードを 反映・破棄 したタイミング
        - つまり React のライフサイクルで 実行される副作用 であるか？
        - Yes → useEffect を利用する手段を用いる (パターン 1)
        - No. → 副作用の内容を見直す必要がある
    - 余談: そもそも副作用でない場合の分岐
      - 先程のフローチャートを始める前に、以下の問いを検討することが推奨される
      - α. 実行したい処理は 外部システムの値を読み取る or 値に影響を与えるか？
        - Yes → 副作用である → β へ
        - No → 副作用ではない → React 内部の仕組みを極力利用する
          - 例
            - useEffect で 状態群 の変更にそって state を更新する
              - 代替案: useEffect を用いずに 直接 state から値を導出する (適宜 `useMemo`を利用)
            - useEffect で state の初期化を行う
              - 代替案: key 属性を用いて コンポーネントの再生成を制御する
            - useEffect で アプリケーション全体の初期化を行う
              - 代替案: コンポーネント外部で 初期化処理を実行する
          - 詳しい解説は省略する
      - β. 実行したい処理は 外部システムの値 → React の状態同期 であるか？
        - Yes → 副作用だが、 useEffect を用いない手段を検討する
          - 例
            - localStorage から値を読み取る
              - 代替案: `useSyncExternalStore` を用いて同期的に値を読み取る
            - IndexedDB から値を読み取る
              - 代替案: `useSyncExternalStore` を用いて同期的に値を読み取る
            - fetch を用いて 非同期にデータを取得する
              - 代替案: React Query, SWR のような データフェッチ支援ライブラリ を利用する
        - No → 先程のフローチャート に従って 分岐を続ける
    - このフローチャートに沿って 副作用を記述していくことが好ましい
    - ただし、これは用法を意識したガイドラインであり、
      - 実際の開発では いくつかの注意点がある
    - 実際の開発では これらのパターンが不可分である場合がある
      - 例: websocket の受信 (パターン 1 と パターン 3b が不可分)
        - まず websocket 接続を確立する (パターン 1)
        - 次に 受信イベントハンドラを登録する (パターン 3b)
        - この場合、同一 useEffect 内で パターン 1 と パターン 3b の両方の役割を果たす方が自然である
        - 無理に パターン 1 と パターン 3b を分割するメリットはなく、かえって 保守が難しくなる
        - そもそも ライブラリが 提供する API 自体が これらのパターンを分割できない場合もある
    - では useEffect の分割境界はどこにあるのか？
      - React 公式は
      - 一つの useEffect ごとに、一つの外部システム への同期 となる設計を推奨している
      - その指標には、「依存配列が一致する」ということが挙げられる
      - 同じ外部システム にアクセスしており、かつ 依存配列が同じ場合は
        - 一つの外部システムへの同期 と捉えられるため
        - それらを一つの useEffect にまとめるべきである可能性が高い
      - 逆に、依存配列が異なる場合や、異なる外部システム への同期である場合は
        - それらを別々の useEffect に分割することが推奨される
    - 以上、イベントハンドラや useEffect を用いた 副作用の記述手段について解説した

  - これらの副作用実行手段 に加えて、
  - 副作用を記述しやすくするための 補助的な手段も提供されている
    - useRef と ref 属性
      - コンポーネントに、任意の値を入れられるオブジェクトや 実 DOM ノード への参照を提供する手段
      - 先程の 副作用処理の中で、DOM ノードを直接操作する処理で登場したもの
      - useRef は、どちらかというと、副作用実行手段 というよりは 副作用の処理を記述する際に 利用するための補助的な手段である
      - useRef は 2 つの責務を持つ
        - どちらも「関数コンポーネントの実行外部で ミュータブルな値を保持・参照する」ための手段である
      - 1. 任意の値を入れられるオブジェクトの提供
        - 関数コンポーネント内で `useRef` を呼び出すと `ref` オブジェクト が得られる
        - この ref オブジェクトとは、
        - ミュータブルに利用でき、任意の値を入れられるオブジェクト `ref.current` を持つオブジェクトである
        - これにより 関数コンポーネントの実行外部で ミュータブルな値を保持できるようになる
      - 2. 実 DOM ノード への参照の取得
        - 1 で入手した ref オブジェクト を コンポーネントの `ref` 属性 に渡すと
        - `ref.current` が 任意の値 ではなく
        - ref 属性を与えた コンポーネント の 実 DOM ノード を参照するようになる
        - これにより 関数コンポーネントの実行外部で 実 DOM ノード への参照を取得できるようになる
        - 余談: `ref` 属性を与えるコンポーネントは、
          - 関数コンポーネントではなく DOM を持つ コンポーネントである必要がある
            - DOM を持つ コンポーネント = HostComponent と呼ばれる
          - 関数コンポーネントが `ref` 属性 を受け取る場合は、
          - 関数コンポーネント内で HostComponent に `ref` を受け渡す必要がある
      - 基本的な React のスタンスは、
        - 関数コンポーネントの実行の内部では
        - ミュータブルな値や 実 DOM ノード への参照を扱わないことを前提にしている
      - そのため、useRef で得られた`ref.current` は、
      - イベントハンドラや useEffect 内部のような 副作用実行手段 の中で利用することが想定されている
  - 以上、副作用実行手段および、副作用を記述しやすくするための補助的な手段について解説した
  - これらの副作用実行手段は、
    - f(...) = React 要素 という純粋関数性を保ちながら、
    - 外部システム との やり取りを 関数コンポーネントの外部に逃がすために提供された手段である
    - 開発者は、React の思想に反しないように
      - 外部システムとのやり取りを
      - 副作用実行手段 を用いて
      - イベントハンドラや useEffect 内部に記述し、
      - 関数コンポーネントの外部で実行するように注意する必要がある
