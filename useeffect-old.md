- f(...) = React 要素 という純粋関数性 を保ち、副作用を外部に逃がすための 手段

  - React は f(...) = React 要素 という純粋関数性 を保つことを前提に設計されていることは前述した
  - React 要素 を生成する関数コンポーネントには、
    - React 管轄外の 外部システム とのやり取り(副作用) の記述 を含めるべきではない
    - React 管轄外 の 外部システム とのやり取りの例は 前述の通り
  - そのため React は、関数コンポーネント実行の「外部」で副作用 の実行を設定する手段を提供している
  - 副作用の記法の解説をする前に、重要な仕組みである useEffect について触りだけ解説する
  - 前提知識: useEffect

    - まずは この useEffect の技術的な詳細と、簡単なマインドセットを解説する
    - useEffect は、技術的に見れば
    - React 要素から生成された 変更が 実 DOM に反映された後 に
      - 任意のフック処理を差し込むことができる仕組みのこと
      - 以下の 2 つの処理が差し込める
        - ①. セットアップ処理
          - 実 DOM ノードが 反映された後 (マウント直後) に実行される処理
        - ②. クリーンアップ処理
          - 実 DOM ノードが 破棄された後 (アンマウント直後) に実行される処理
      - また、依存配列というものを指定することもできる
        - 依存配列: 副作用処理が依存している入力値
        - 副作用処理が依存している値 とはつまり React が値の変化を検知する必要のある値である ということ
        - 依存配列には、状態群 (state, props, context) や 状態群から導出した値、
        - 関数コンポーネント内で作成した値など
        - React 管轄内の値 のみを含める必要がある
      - 依存配列を指定すると、フック処理が以下のようになる
        - ①. セットアップ処理
          - 実 DOM ノードが 反映された後 (マウント直後) に実行される (従来と同じ)
          - 依存配列が変化したタイミングで、前回のクリーンアップ処理の後に実行される
        - ②. クリーンアップ処理
          - 実 DOM ノードが 破棄された後 (アンマウント直後) に実行される (従来と同じ)
          - 依存配列が変化したタイミングで、次回のセットアップ処理の前に実行される
      - つまり、依存配列が変化すると
        - 1. 前回のクリーンアップ処理 が実行される (掃除をする)
        - 2. 次に、今回のセットアップ処理 が実行される (新しい準備をする)
      - 余談: useEffect の依存配列は React 管轄内の値 のみを含める必要がある
        - useEffect の依存配列は 「どのような値でも変化を検知できる」わけではない
        - そのため、React 外部の値 を依存配列に含めても 変化を検知できない
        - 仕組みは以下の通り
          - React の仕組みとして、
          - 状態群 (state, props, context) の変化に合わせて 関数コンポーネントを再実行する ことは 前述の通り
          - 関数コンポーネントが再実行されたとき、
          - 前回の実行時と今回の実行時の 依存配列内の値 をそれぞれ比較し
          - いずれかの値が変化していた場合にのみ
          - useEffect 内のフック処理を再実行する仕組み となっている
        - そのため、依存配列に React 管轄外 である 外部システムの値を含めたとしても
          - React に外部システムの値の変化を検知する仕組みがないため
          - 依存配列に React 外部の値を含めることは意味がない
          - 依存配列には React 管轄内の値 のみを含める必要がある
      - useEffect の技術的な側面は以上である
        - しかし、技術的な側面だけ見て useEffect を利用すると
        - React の設計思想に反した使い方をしてしまう可能性が高い
    - React は useEffect を
      - React 外部のシステムに対し、
      - React の UI 反映 後のタイミング に処理を差し込むことで、
      - React の UI 更新のライフサイクル に合わせて 外部のシステムと React の状態を同期させるための手段
      - として定義している
      - useEffect の実行は、UI 反映後に発火するフック処理 といえる
    - useEffect を利用するときは 「外部システムと React の状態を同期させる手段」というマインドが重要である
      - このマインドがないと、useEffect の誤用が発生しやすくなる
      - これを念頭に置くこと
    - useEffect 利用の特性
      - useEffect の使い方は、大きく 3 つのパターンに分割できる
      - これらをあらかじめ提示しておく
        - α. React 外部のシステムに対して 特定のイベント発生時に実行する処理の登録・登録解除を行う
          - 依存配列は []
            - 空配列にすると eslint ルールに怒られる場合は useEffectEvent (後述) を利用すること
          - 余談:
            - 「特定のイベント発生時に実行する処理」自体が副作用である
            - かつ、その登録・登録解除も副作用である
            - ということを理解しておくこと
        - β. React 外部のシステムに対して 初期化・破棄 を行う
          - 依存配列は 多くの場合 []
            - もし 追加で 何かの値に依存する場合は eslint ルールに従うこと
        - γ. React 外部のシステムに対して、 React 内部の state の値を同期させる
          - 依存配列は [state, ...] (同期させたい state を必ず含む)
            - その他の依存配列の値は eslint ルールに従うこと
      - 注意点
        - α の 処理は、
          - 副作用処理の登録 = 初期化
          - 副作用処理の解除 = 破棄
        - と捉えることもできるため、本来は β の一部
        - しかし今回は、α と β を区別して解説する
    - 準備が整ったところで、副作用の記述手段について解説する

  - 副作用記述の手段

    - React は、副作用の記述手段として いくつかの手段を提供している

    - イベントハンドラ内への副作用記述

      - 何かのイベントが発生したときに、対応する処理を実行するコールバック関数
        - イベントハンドラ内には、外部システムに対して影響を与える処理を記述して良い
        - そのため、イベントハンドラは 副作用の実行手段の一つである
      - 特定のイベントに紐づく副作用は イベントハンドラに記述する必要がある
      - 例:
        - 特定のボタンが押されたイベントに対して、処理を実行する
        - キーボードが押されたイベントに対して、処理を実行する
        - ウィンドウのリサイズイベントに対して、処理を実行する
        - 外部サーバからの websocket 通知イベントに対して、処理を実行する
        - setTimeout や setInterval のタイマーイベントに対して、処理を実行する
          - 余談: setTimeout や setInterval の場合は
            - 厳密には イベントハンドラ ではないが、
            - 「一定時間経過後」や 「一定時間ごと」というイベントで発火する
            - イベントハンドラ 的な性質を持つため、ここでは イベントハンドラ の一種として扱う
      - イベントハンドラの処理は 関数コンポーネント実行の外部で実行されるため、
        - イベントハンドラに副作用を設定することは、
        - 副作用を実行する手段として一番最適であり、基本的な手段である
      - このイベントハンドラを登録・実行する手段として、以下の 2 つの手段が提供されている

        - イベントハンドラ属性 による自動での副作用登録
          - イベントハンドラを設定するための基本的な手段
          - 関数コンポーネントが生成する React 要素 の 属性として
          - イベントハンドラとなる関数を登録する手段
            - 例: onClick 属性 に ボタンが押された時の処理を登録する
          - 例:
            - ボタンが押された時に新しくウィンドウを開くイベントハンドラの登録
              - `onClick` 属性 に `() => window.open(...)` のようなイベントハンドラを登録する
            - ボタンが押されたときに 外部サーバにデータを送信するイベントハンドラの登録
              - `onClick` 属性 に `() => fetch(...)` のようなイベントハンドラを登録する
          - この場合、React が実際のイベントハンドラ登録を担ってくれるため
            - 開発者は イベントハンドラの登録・解除を自力で実装する必要がない
        - useEffect による手動での副作用登録

          - イベントハンドラ属性が使えない場合の補完的な手段
            - useEffect を 「α. 特定のイベント発生時に実行する処理の登録・登録解除を行う」用途で用いる
          - 先程解説したイベントハンドラ属性は 対応する React 要素 が存在しない場合には利用できない
          - 例えば
            - キーボードが押されたときに処理を実行したい場合
            - ウィンドウのリサイズ時に処理を実行したい場合
            - 外部サーバからの websocket 通知を受け取ったときに処理を実行したい場合
            - setTimeout や setInterval を用いて 時間経過後に処理を実行したい場合
          - その場合、useEffect フック を用いて
            - イベントハンドラの登録・解除を自力で実装する必要がある
          - 例:
            - キーボードが押されたときに処理を実行するようなイベントハンドラの登録・解除
              - イベントハンドラの登録: `window.addEventListener('keydown', handler)` のような関数を呼び出し、登録
              - イベントハンドラの解除: `window.removeEventListener('keydown', handler)` のような関数を呼び出し、解除
            - ウィンドウのリサイズ時に処理を実行するようなイベントハンドラの登録・解除
              - イベントハンドラの登録: `window.addEventListener('resize', handler)` のような関数を呼び出し、登録
              - イベントハンドラの解除: `window.removeEventListener('resize', handler)` のような関数を呼び出し、解除
            - 外部サーバからの websocket 通知を受け取ったときに処理を実行するようなイベントハンドラの登録・解除
              - イベントハンドラの登録: `websocket.addEventListener('message', handler)` のような関数を呼び出し、登録
              - イベントハンドラの解除: `websocket.removeEventListener('message', handler)` のような関数を呼び出し、解除
            - setTimeout や setInterval を用いて 時間経過後に処理を実行するようなイベントハンドラの登録・解除
              - イベントハンドラの登録: `const id = setTimeout(handler, delay)` や `const id = setInterval(handler, interval)` のような関数を呼び出し、登録
              - イベントハンドラの解除: `clearTimeout(id)` や `clearInterval(id)` のような関数を呼び出し、解除
          - 注意すべき点
            - イベントハンドラ属性を利用すると
              - React がイベントハンドラの登録・解除を自動的に行ってくれる
            - useEffect フックを利用すると、
              - 開発者が イベントハンドラの登録・解除を自力で実装する必要がある
                - 不慣れな場合、クリーンアップ関数で イベントハンドラの解除を行うのを忘れがちになる
              - イベントハンドラの解除処理を忘れると メモリリークや 重複登録のバグが発生する可能性がある
                - そのため、開発者がイベントハンドラの登録だけでなく
                - イベントハンドラの解除まで責任を持ち、実装する必要がある
            - この性質は useEffect の β. 初期化・破棄 の場合も同様である
          - 余談: useEffectEvent
            - useEffect で イベントハンドラを登録・解除する場合、
            - 依存配列を 空配列にすることが望ましい
            - ただし依存配列を空配列にすると、eslint ルールに怒られる場合がある
            - その場合、イベントハンドラ の コールバック関数を useEffectEvent で生成することで
            - 依存配列を空配列にしても eslint ルールに怒られなくなる

        - イベントハンドラ属性と useEffect フック の使い分け
          - React 要素の中で イベントハンドラ属性を用いることが可能な場合は
          - 基本的にこの手段を用いることが推奨される
          - 該当する React 要素 が存在しない場合は イベントハンドラ属性を用いることができないため
          - useEffect フックを利用して 副作用を設定する必要がある
          - useEffect は あくまでも イベントハンドラで副作用を設定できない場合の補完手段であるため、
          - useEffect フック を用いる場合は 本当にイベントハンドラで副作用を設定できないのかを 注意深く検討する必要がある

    - useEffect 内 への 副作用記述
      - 先程解説した useEffect の使い方は
        - α. 特定のイベント発生時に実行する処理の登録・登録解除を行う
        - という使い方であった
      - 一方で、useEffect は
        - β. React 外部のシステムに対して 初期化・破棄 を行う
        - γ. React 外部のシステムに対して、 React 内部の state の値を同期させる
        - という使い方もできる
      - ここからは、この β と γ の使い方について解説する
      - 実行したい副作用が 特定のイベントに紐づかない場合、イベントハンドラを使うべきではない
      - そのため、β か γ の使い方を検討する必要がある
      - useEffect フック 内に記述された関数 は
        - React 要素 が 実際の 実 DOM に反映された後に実行されるため、これも関数コンポーネントの外部で実行されることになる
        - useEffect フック 内に 副作用を記述することで 副作用を適切に実行することができる
      - β. React 外部のシステムに対して 初期化・破棄 を行う
        - ネットワーク越しの外部サーバへの接続確立
          - 初期化 = 外部サーバへの接続確立
            - `createConnection()` のような関数を呼び出し、接続を確立
          - 破棄 = 外部サーバへの接続解除
            - `connect.close()` のような関数を呼び出し、接続を解除
            - クリーンアップ関数で実装する
        - React に対応していない コンポーネントライブラリ の初期化・破棄
          - 初期化 = コンポーネントライブラリの初期化
            - useRef (後述) で DOM ノード を取得し そこに React に対応していない コンポーネントライブラリ を代入する
          - 破棄 = コンポーネントライブラリの破棄
            - DOM ノードから コンポーネントライブラリ の `destroy()` のような関数を呼び出し、破棄する
            - クリーンアップ関数で実装する
        - 亜種: 外部サーバへのログ送信
          - 外部サーバへのログ送信 のような 処理の初期化・破棄 も β の一種と捉えられるが、
          - この場合は 破棄が必要ない
          - 初期化 = ログ送信
            - `fetch` のような関数を呼び出し、ログを送信
          - 破棄 = なし
      - γ. React 外部のシステムに対して、 React 内部の state の値を同期させる
        - DOM ノード の直接操作
          - 具体例: `<video>` の再生制御
          - React の state に合わせて 再生・一時停止 を切り替える
            - DOM ノード を useRef (後述) で取得し、それに対して 再生・一時停止 を指示
          - 宣言的な React の state の世界から、命令的な DOM ノード の指示へ橋渡しを行うイメージ
            - この場合、依存配列に state を含める
          - また、この場合はクリーンアップ関数は不要
      - useEffect の使い方は、おおよそ以上である
      - 余談: 今回解説しなかった useEffect の使い方: 外部システムの値 → React の状態同期
        - 今回は、外部システムの値 → React の状態同期 という使い方は解説しなかった
        - これらの方法は useEffect を利用するよりも
        - 別の手段を用いることが推奨されるためである
        - 具体的には、以下の手段がある
        - 同期的な値の読み取り
          - `localStorage` や `IndexedDB` のような
          - ブラウザのストレージ からの同期的な値の読み取りにも useEffect を利用することはできるが、推奨されない
          - 推奨する手段は以下の通り
            - React 18 で導入された `useSyncExternalStore` の利用
            - React 外部のシステムの値を同期的に読み取るための手段を提供している
            - これにより、React 外部のシステムの値を React の状態として扱うことができる
            - 詳細は後述
        - 非同期なデータフェッチ (非推奨)
          - `fetch` のような HTTP クライアント を用いた
          - 非同期なデータフェッチ にも useEffect を利用することはできるが、推奨されない
          - 推奨する手段は以下の通り
            - React Query, SWR のような データフェッチ支援ライブラリ を利用する
          - これらのライブラリは
            - 外部サーバのデータを React の state と同期させるための手段を提供しており、
            - 自前で useEffect を用いて データフェッチ周りの処理を実装する必要がなくなる
            - また キャッシュ管理 の 他にも 再試行、ポーリング、データの永続化などの機能を提供している
            - これらの処理は 独自実装すると非常に難しく コストが高いが
            - これらのライブラリを利用することで ライブラリに実装を任せることができる
            - また、後述する コンポーネントのサスペンド機能も提供していることが多い
          - したがって、
            - 非同期なデータフェッチ に useEffect を用いることは避け、
            - これらの専用ライブラリを利用することが推奨される
    - 副作用をどのように記述すべきか？フローチャート
      - 1. 副作用が 特定のイベントに紐づくか？
        - Yes → 2 へ
        - No → 3 へ
      - 2. 対応する React 要素 が存在するか？
        - Yes → イベントハンドラ属性 に副作用を記述する
        - No → useEffect フック を用いて イベントハンドラを登録・解除する処理を記述する (α の使い方)
      - 3. 外部システムに対して 初期化・破棄 を行うか？
        - Yes → useEffect フック を用いて 初期化・破棄 を行う処理を記述する (β の使い方)
        - No → 4 へ
        - 4. 外部システムに対して、 React 内部の state の値を同期させるか？
          - Yes → useEffect フック を用いて state の値を同期させる処理を記述する (γ の使い方)
          - No → useEffect の使い方を見直す
      - 余談: そもそも副作用でない場合の分岐
        - 1. 実行したい処理は 外部システムの値を読み取る or 値に影響を与えるか？
          - Yes → 副作用である → 上記のフローチャートへ
          - No → 副作用ではない → React 内部の仕組みを極力利用する
            - state から値を導出する (適宜 `useMemo`を利用)
            - key 属性を用いて コンポーネントの再生成を制御する
            - ここでは詳しい解説はしない
    - このフローチャートに沿って 副作用を記述していくことが好ましい
    - ただし、これは用法を意識したガイドラインであり、
      - 実際の開発では いくつかの注意点がある
    - 実際の開発では α と β は不可分であり、分割をすべきではない
      - 例: websocket の受信
        - まず websocket 接続を確立する (β)
        - 次に 受信イベントハンドラを登録する (α)
        - この場合、同一 useEffect 内で α と β の両方の役割を果たすことになる
        - 無理に α と β を分割するメリットはなく、かえって 保守が難しくなる
        - そもそも ライブラリが α と β の分割に対応していない場合も多い
    - では useEffect の分割境界はどこにあるのか？
      - React 公式は
      - 一つの useEffect ごとに、一つの外部システム への同期 となる設計を推奨している
      - その指標には、「依存配列が一致する」ということが挙げられる
      - 同じ外部システム にアクセスしており、かつ 依存配列が同じ場合は
        - 一つの外部システムへの同期 と捉えられるため
        - それらを一つの useEffect にまとめるべきである可能性が高い
      - 逆に、依存配列が異なる場合や、異なる外部システム への同期である場合は
        - それらを別々の useEffect に分割することが推奨される
    - 以上、イベントハンドラや useEffect を用いた 副作用の記述手段について解説した
